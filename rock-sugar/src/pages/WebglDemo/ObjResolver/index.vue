<template lang="html">
    <body>
        <div class="webglContainer">
            <div class="canvesContainer">
                <canvas id="canvas">
                </canvas>
            </div>
        </div>
        <div class="desContainer">
            <div class="des">
                <div class="title">
                    <span id="category">webgl</span>
                    <span id="name">ObjResolver</span>
                </div>
                <div class="codeLink">
                    <nano_button @handleClick="handleClick"></nano_button>
                </div>
            </div>
            <div class="conclusion">
                <span class="title"><span id="conTitle">模型渲染</span></span>
                <span class="content">I can't build a model of the future, let alone render it.</span>
            </div>
        </div>
    </body>
</template>
<script>
export default {
    name:"ObjResolver",
    mounted() {
        this.Render();
    },
    methods: {
        Render(){
            "use strict";
    function parseOBJ(text) {
        // because indices are base 1 let's just fill in the 0th data
        const objPositions = [[0, 0, 0]];
        const objTexcoords = [[0, 0]];
        const objNormals = [[0, 0, 0]];
        const objColors = [[0, 0, 0]];

        // same order as `f` indices
        const objVertexData = [
            objPositions,
            objTexcoords,
            objNormals,
            objColors,
        ];

        // same order as `f` indices
        let webglVertexData = [
            [],   // positions
            [],   // texcoords
            [],   // normals
            [],   // colors
        ];

        const materialLibs = [];
        const geometries = [];
        let geometry;
        let groups = ['default'];
        let material = 'default';
        let object = 'default';

        const noop = () => {};

        function newGeometry() {
            // If there is an existing geometry and it's
            // not empty then start a new one.
            if (geometry && geometry.data.position.length) {
            geometry = undefined;
            }
        }

        function setGeometry() {
            if (!geometry) {
            const position = [];
            const texcoord = [];
            const normal = [];
            const color = [];
            webglVertexData = [
                position,
                texcoord,
                normal,
                color,
            ];
            geometry = {
                object,
                groups,
                material,
                data: {
                position,
                texcoord,
                normal,
                color,
                },
            };
            geometries.push(geometry);
            }
        }

        function addVertex(vert) {
            const ptn = vert.split('/');
            ptn.forEach((objIndexStr, i) => {
            if (!objIndexStr) {
                return;
            }
            const objIndex = parseInt(objIndexStr);
            const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
            webglVertexData[i].push(...objVertexData[i][index]);
            // if this is the position index (index 0) and we parsed
            // vertex colors then copy the vertex colors to the webgl vertex color data
            if (i === 0 && objColors.length > 1) {
                geometry.data.color.push(...objColors[index]);
            }
            });
        }

        const keywords = {
            v(parts) {
            // if there are more than 3 values here they are vertex colors
            if (parts.length > 3) {
                objPositions.push(parts.slice(0, 3).map(parseFloat));
                objColors.push(parts.slice(3).map(parseFloat));
            } else {
                objPositions.push(parts.map(parseFloat));
            }
            },
            vn(parts) {
            objNormals.push(parts.map(parseFloat));
            },
            vt(parts) {
            // should check for missing v and extra w?
            objTexcoords.push(parts.map(parseFloat));
            },
            f(parts) {
            setGeometry();
            const numTriangles = parts.length - 2;
            for (let tri = 0; tri < numTriangles; ++tri) {
                addVertex(parts[0]);
                addVertex(parts[tri + 1]);
                addVertex(parts[tri + 2]);
            }
            },
            s: noop,    // smoothing group
            mtllib(parts, unparsedArgs) {
            // the spec says there can be multiple filenames here
            // but many exist with spaces in a single filename
            materialLibs.push(unparsedArgs);
            },
            usemtl(parts, unparsedArgs) {
            material = unparsedArgs;
            newGeometry();
            },
            g(parts) {
            groups = parts;
            newGeometry();
            },
            o(parts, unparsedArgs) {
            object = unparsedArgs;
            newGeometry();
            },
        };

        const keywordRE = /(\w*)(?: )*(.*)/;
        const lines = text.split('\n');
        for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
            const line = lines[lineNo].trim();
            if (line === '' || line.startsWith('#')) {
            continue;
            }
            const m = keywordRE.exec(line);
            if (!m) {
            continue;
            }
            const [, keyword, unparsedArgs] = m;
            const parts = line.split(/\s+/).slice(1);
            const handler = keywords[keyword];
            if (!handler) {
            console.warn('unhandled keyword:', keyword);  // eslint-disable-line no-console
            continue;
            }
            handler(parts, unparsedArgs);
        }

        // remove any arrays that have no entries.
        for (const geometry of geometries) {
            geometry.data = Object.fromEntries(
                Object.entries(geometry.data).filter(([, array]) => array.length > 0));
        }

        return {
            geometries,
            materialLibs,
        };
        }
            
        async function main() {
    // Get A WebGL context
    /** @type {HTMLCanvasElement} */
    const canvas = document.querySelector("#canvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
        return;
    }

    const vs = `
    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec4 a_color;

    uniform mat4 u_projection;
    uniform mat4 u_view;
    uniform mat4 u_world;

    varying vec3 v_normal;
    varying vec4 v_color;

    void main() {
        gl_Position = u_projection * u_view * u_world * a_position;
        v_normal = mat3(u_world) * a_normal;
        v_color = a_color;
    }
    `;

    const fs = `
    precision mediump float;

    varying vec3 v_normal;
    varying vec4 v_color;

    uniform vec4 u_diffuse;
    uniform vec3 u_lightDirection;

    void main () {
        vec3 normal = normalize(v_normal);
        float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
        vec4 diffuse = u_diffuse * v_color;
        gl_FragColor = vec4(diffuse.rgb * fakeLight, diffuse.a);
    }
    `;


    // compiles and links the shaders, looks up attribute and uniform locations
    const meshProgramInfo = haruluya_webgl_utils.createProgramInfo(gl, [vs, fs]);

    const response = await fetch('https://webglfundamentals.org/webgl/resources/models/book-vertex-chameleon-study/book.obj');  
    const text = await response.text();
    const obj = parseOBJ(text);

    const parts = obj.geometries.map(({data}) => {
        // Because data is just named arrays like this
        //
        // {
        //   position: [...],
        //   texcoord: [...],
        //   normal: [...],
        // }
        //
        // and because those names match the attributes in our vertex
        // shader we can pass it directly into `createBufferInfoFromArrays`
        // from the article "less code more fun".

        if (data.color) {
        if (data.position.length === data.color.length) {
            // it's 3. The our helper library assumes 4 so we need
            // to tell it there are only 3.
            data.color = { numComponents: 3, data: data.color };
        }
        } else {
        // there are no vertex colors so just use constant white
        data.color = { value: [1, 1, 1, 1] };
        }

        // create a buffer for each array by calling
        // gl.createBuffer, gl.bindBuffer, gl.bufferData
        const bufferInfo = haruluya_webgl_utils.createBufferInfoFromArrays(gl, data);
        return {
        material: {
            u_diffuse: [1, 1, 1, 1],
        },
        bufferInfo,
        };
    });

    function getExtents(positions) {
        const min = positions.slice(0, 3);
        const max = positions.slice(0, 3);
        for (let i = 3; i < positions.length; i += 3) {
        for (let j = 0; j < 3; ++j) {
            const v = positions[i + j];
            min[j] = Math.min(v, min[j]);
            max[j] = Math.max(v, max[j]);
        }
        }
        return {min, max};
    }

    function getGeometriesExtents(geometries) {
        return geometries.reduce(({min, max}, {data}) => {
        const minMax = getExtents(data.position);
        return {
            min: min.map((min, ndx) => Math.min(minMax.min[ndx], min)),
            max: max.map((max, ndx) => Math.max(minMax.max[ndx], max)),
        };
        }, {
        min: Array(3).fill(Number.POSITIVE_INFINITY),
        max: Array(3).fill(Number.NEGATIVE_INFINITY),
        });
    }

    const extents = getGeometriesExtents(obj.geometries);
    const range = haruluya_webgl_utils.subtractVectors(extents.max, extents.min);
    // amount to move the object so its center is at the origin
    const objOffset = haruluya_webgl_utils.scaleVector(
        haruluya_webgl_utils.addVectors(
            extents.min,
            haruluya_webgl_utils.scaleVector(range, 0.5)),
        -1);
    const cameraTarget = [0, 0, 0];
    // figure out how far away to move the camera so we can likely
    // see the object.
    const radius = haruluya_webgl_utils.length(range) * 1.2;
    const cameraPosition = haruluya_webgl_utils.addVectors(cameraTarget, [
        0,
        0,
        radius,
    ]);
    // Set zNear and zFar to something hopefully appropriate
    // for the size of this object.
    const zNear = radius / 100;
    const zFar = radius * 3;

    function degToRad(deg) {
        return deg * Math.PI / 180;
    }

    function render(time) {
        time *= 0.001;  // convert to seconds

        haruluya_webgl_utils.resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.enable(gl.DEPTH_TEST);

        const fieldOfViewRadians = degToRad(60);
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projection = haruluya_webgl_utils.perspective(fieldOfViewRadians, aspect, zNear, zFar);

        const up = [0, 1, 0];
        // Compute the camera's matrix using look at.
        const camera = haruluya_webgl_utils.lookAt(cameraPosition, cameraTarget, up);

        // Make a view matrix from the camera matrix.
        const view = haruluya_webgl_utils.inverse(camera);

        const sharedUniforms = {
        u_lightDirection: haruluya_webgl_utils.normalize([-1, 3, 5]),
        u_view: view,
        u_projection: projection,
        };

        gl.useProgram(meshProgramInfo.program);

        // calls gl.uniform
        haruluya_webgl_utils.setUniforms(meshProgramInfo, sharedUniforms);

        // compute the world matrix once since all parts
        // are at the same space.
        let u_world = haruluya_webgl_utils.yRotation(time);
        u_world = haruluya_webgl_utils.translate3d(u_world, ...objOffset);

        for (const {bufferInfo, material} of parts) {
        // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
        haruluya_webgl_utils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);
        // calls gl.uniform
        haruluya_webgl_utils.setUniforms(meshProgramInfo, {
            u_world,
            u_diffuse: material.u_diffuse,
        });
        // calls gl.drawArrays or gl.drawElements
        haruluya_webgl_utils.drawBufferInfo(gl, bufferInfo);
        }

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
    }
    main();
        }
    },
}
</script>
<style lang="less" scoped>
@import "../index.less";
</style>