{"version":3,"file":"js/954.8f911072.js","mappings":"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","sources":["webpack://rock-sugar/./src/pages/CG/Experiment/Interfaces/Polygon.js","webpack://rock-sugar/./src/pages/CG/Experiment/WeilerAthenton/index.vue","webpack://rock-sugar/./src/pages/CG/Experiment/Interfaces/Line.js","webpack://rock-sugar/./src/pages/CG/Experiment/Interfaces/InPoint.js","webpack://rock-sugar/./src/pages/CG/Experiment/WeilerAthenton/index.vue?a688"],"sourcesContent":["/*\r\n    @author:haruluya\r\n    @des:The obstraction of polygon\r\n    @params:{\r\n        points:the points of polygon.\r\n    }\r\n*/\r\nclass Polygon{\r\n    constructor(points){\r\n        this.points = points\r\n        this.points.forEach((e,i)=>{\r\n            this[i] = e;\r\n        })\r\n    }\r\n    maxPointX(){\r\n        let max = 0;\r\n        this.points.forEach(element => {\r\n            max = max > element.x ? max : element.x;\r\n        });\r\n        return max;\r\n    }\r\n    minPointX(){\r\n        let min = this.maxPointX();\r\n        this.points.forEach(element =>{\r\n            min = min < element.x ? min : element.x;\r\n        })\r\n        return min;\r\n    }\r\n    maxPointY(){\r\n        let max = 0;\r\n        this.points.forEach(element => {\r\n            max = max > element.y ? max : element.y;\r\n        });\r\n        return max;\r\n    }\r\n    minPointY(){\r\n        let min = this.maxPointX();\r\n        this.points.forEach(element =>{\r\n            min = min < element.y ? min : element.y;\r\n        })\r\n        return min;\r\n    }\r\n    size(){\r\n        return this.points.length;\r\n    }\r\n    indexValue(index){\r\n        return this.points[index];\r\n    }\r\n    isInPolygon(point){\r\n        let i, j;\r\n        let c = false;\r\n        for (i=0, j=this.size()-1; i<this.size(); j=i++)\r\n        {\r\n            if(((this.points[i].y>point.y) != (this.points[j].y>point.y)) &&\r\n                (point.x<(this.points[j].x-this.points[i].x) *\r\n                (point.y-this.points[i].y) / (this.points[j].y-this.points[i].y) + this.points[i].x))\r\n            c = !c;\r\n        }\r\n        return c;\r\n    }\r\n}\r\nexport default Polygon;","<template lang=\"html\">\r\n    <nano_cg_experiment_page :prop_des_data=\"desData\" :prop_ui_setter=\"uiSetter\" :prop_section_params=\"sectionParams\"\r\n        ref=\"page\" />\r\n</template>\r\n<script>\r\n\r\nimport uiSetting from \"../ui-setting\"\r\nimport { Point,Polygon,Rect,Line, InPoint} from \"../Interfaces\"\r\n\r\nconst desData = {\r\n    category: \"Experiment\",\r\n    name: \"WeilerAthenton\",\r\n    buttonContent: \"查看源码\",\r\n    title: \"WeilerAthenton算法\",\r\n    content: \"WeilerAthenton.\"\r\n}\r\n\r\n\r\n\r\n/*\r\n    @author:haruluya\r\n    @des: Ex12 WeilerAthenton.\r\n*/\r\n\r\nexport default {\r\n    name: \"WeilerAthenton\",\r\n    data() {\r\n        return {\r\n            canvas: null,\r\n            ctx: null,\r\n            // component data.\r\n            desData,\r\n            // params of page.\r\n            sectionParams: {\r\n                pn:4,\r\n                vn:5,\r\n                pp:[new Point(100,100),new Point(300,200),new Point(100,300),new Point(200,200)],\r\n                vp:[new Point(100,150),new Point(250,150),new Point(250,250),new Point(100,250),new Point(220,200)],\r\n                pLine:[],\r\n                vLine:[],\r\n                ppoint:[],\r\n                vpoint:[],\r\n                innerColor:'#0bc6e3',\r\n                outerColor:'#ffffff',\r\n                clipColor:'#000000',\r\n                debugContent: null,\r\n                girdSize: 2,\r\n                screenTransform:{x:-20,y:-80,scale:100}\r\n            }\r\n        };\r\n    },\r\n\r\n    computed: {\r\n        //uiSetter.\r\n        uiSetter() {\r\n            let sectionParams = this.sectionParams;\r\n            let setter = [\r\n                {\r\n                    type: \"slider\", id: \"girdSize\", value: sectionParams.girdSize, min: 1, max: 100,\r\n                    callback: uiSetting.globalUiCallbacks.updateValue(this, \"girdSize\")\r\n                },\r\n                { type: \"color\",id: \"innerColor\",default: sectionParams.innerColor, callback: \r\n                    uiSetting.globalUiCallbacks.updateValue(this, \"innerColor\")},\r\n                { type: \"color\",id: \"outerColor\",default: sectionParams.outerColor, callback: \r\n                    uiSetting.globalUiCallbacks.updateValue(this, \"outerColor\")},\r\n                { type: \"color\",id: \"clipColor\",default: sectionParams.clipColor, callback: \r\n                    uiSetting.globalUiCallbacks.updateValue(this, \"clipColor\")},\r\n            ];\r\n            for (let i= 0; i < 2; i++){\r\n                setter.push(\r\n                 { type: \"slider-vector\", id: \"pp\"+i , value: sectionParams.pp[i], min: { x: -300, y: -300 }, max: { x: 300, y: 300 }, callback: \r\n                    uiSetting.globalUiCallbacks.updatePointArray(this, \"pp\", i) },\r\n                )\r\n            }\r\n            for (let i= 0; i < 2; i++){\r\n                setter.push(\r\n                 { type: \"slider-vector\", id: \"vp\"+i , value: sectionParams.vp[i], min: { x: -300, y: -300 }, max: { x: 300, y: 300 }, callback: \r\n                    uiSetting.globalUiCallbacks.updatePointArray(this, \"vp\", i) },\r\n                )\r\n            }\r\n            return setter;\r\n        },\r\n\r\n    },\r\n    methods: {\r\n        Init() {\r\n            this.$refs.page.Init();\r\n            this.canvas = this.$refs.page.getCanvas();\r\n            this.ctx = canvas.getContext('2d');\r\n            this.$refs.page.setViewer(this.sectionParams.screenTransform,this.Render);\r\n            this.Render();\r\n        },\r\n        Render() {\r\n            this.$refs.page.Render();\r\n\r\n            const ctx = this.ctx;\r\n            const gridx = parseInt(this.canvas.width / this.sectionParams.girdSize) - 1;\r\n            const gridy = parseInt(this.canvas.height / this.sectionParams.girdSize) - 1;\r\n\r\n            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n            \r\n            this.sectionParams.girdSize += this.$refs.page.girdSize;\r\n            uiSetting.drawGrid(this);\r\n            if(this.sectionParams.girdSize  <= 0) {\r\n                    this.sectionParams.girdSize = 1\r\n            }\r\n            this.sectionParams.debugContent = [{\r\n                title: \"grid\", content: \"The number of cells in the x direction: \" + gridx + \"\\nThe number of cells in the y direction: \" + gridy,\r\n            }];\r\n          \r\n\r\n            // weilerAthenton.\r\n            const pp = this.sectionParams.pp;\r\n            const vp = this.sectionParams.vp;\r\n            const pn = this.sectionParams.pn;\r\n            const vn = this.sectionParams.vn;\r\n\r\n            //将输入的点从存放到vector中\r\n            let points_p = [],points_v = [];\r\n            for(let i=0;i<pn;++i)points_p.push(pp[i]);\r\n            if(points_p.length<3)\r\n            return;\r\n            for(let i=0;i<vn;++i)points_v.push(vp[i]);\r\n            if(points_v.length<3)\r\n            return;\r\n            let polyp = new Polygon(points_p);\r\n            let polyv = new Polygon(points_v);\r\n\r\n            uiSetting.drawPolygonInGrid(this,polyp,this.sectionParams.outerColor);\r\n            uiSetting.drawPolygonInGrid(this,polyv,this.sectionParams.clipColor);\r\n\r\n            //清理之前的绘图数据\r\n            let pLine = this.sectionParams.pLine;\r\n            let vLine = this.sectionParams.vLine;\r\n            pLine.length = 0;\r\n            vLine.length = 0;\r\n\r\n            let A = new Point(0,0),B = new Point(0,0);\r\n            //对于被裁减多边形，从起点到终点的所有边顺时针插入多边形边链表\r\n            for(let i=0;i<pn-1;++i){\r\n                A.setX(pp[i].x);A.setY(pp[i].y);\r\n                B.setX(pp[i+1].x);B.setY(pp[i+1].y);\r\n                pLine.push(new Line(A,B));\r\n                A.setX(B.x);A.setY(B.y)\r\n            }\r\n            B.setX(pp[0].x);B.setY(pp[0].y);\r\n            pLine.push(new Line(A,B));\r\n\r\n            //对于裁剪窗口，从起点到终点的所有边顺时针插入多边形边链表\r\n            for(let i=0;i<vn-1;++i){\r\n                A.setX(vp[i].x);A.setY(vp[i].y);\r\n                B.setX(vp[i+1].x);B.setY(vp[i+1].y);\r\n                vLine.push(new Line(A,B));\r\n                A.setX(B.x);A.setY(B.y)\r\n            }\r\n            B.setX(vp[0].x);B.setY(vp[0].y);\r\n            vLine.push(new Line(A,B));\r\n\r\n            //根据线段表pLine、vLine得出交点表ppoint,vpoint\r\n            this.SetPLane();\r\n  \r\n            let PointInter = [];//裁剪之后的多边形的坐标\r\n            let Num = [];//每个裁剪后多边形的坐标个数，Num的size表示交集面的个数\r\n            //根据插入好入点出点还有端点的序列ppoint、vpoint，找裁剪后的多边形\r\n            this.BoolIntersection(PointInter, Num);\r\n\r\n            let it = 0,itN = 0;\r\n            let points_ans = [];\r\n            for(itN = 0; itN < Num.length; itN++){\r\n                points_ans = [];\r\n                for(let i = 0; i < Num[itN]; i++){\r\n                    points_ans.push(PointInter[it]);\r\n                    it++;\r\n                }\r\n            }\r\n            uiSetting.drawPolygonInGrid(this,new Polygon(points_ans),this.sectionParams.innerColor);\r\n\r\n        },\r\n        SetPLane(){\r\n            //先清空之前的绘图数据\r\n            let ppoint = this.sectionParams.ppoint;\r\n            let vpoint = this.sectionParams.vpoint;\r\n            let pLine = this.sectionParams.pLine;\r\n            let vLine = this.sectionParams.vLine;\r\n            ppoint.length = 0;\r\n            vpoint.length = 0;\r\n\r\n\r\n            let itp = 0,itv = 0;\r\n            let t = [];//用于保存每条边与其他边相交时交点在线段上的位置\r\n            let tp = new Point(0,0);\r\n            let tt = .0;//对于线段A->B，tt<0代表交点在A左侧，tt==0代表在A，0<tt<1代表在AB中间，tt==1代表在B，tt>1代表在B右侧\r\n\r\n            //对于多边形的每一条边，找到窗口的每一条边（看作线段）与那条边（看作直线）的交点\r\n            for(itp = 0; itp < pLine.length; itp++){\r\n                for(itv = 0; itv < vLine.length; itv++){\r\n\r\n                    const {tag,insert,tt} = this.IsInsect(pLine[itp].P1(),pLine[itp].P2(),\r\n                                vLine[itv].P1(),vLine[itv].P2())\r\n                    if(tag){\r\n                        t.push(tt);\r\n                    }\r\n                }\r\n                t.sort();\r\n                let tInp = new InPoint(new Point(0,0));\r\n                let nt=0;\r\n                let nt_in=0;\r\n                for (let i = 0; i < t.length; i++)\r\n                {\r\n                    if(i!=0&&t[i]==t[i-1])//避免相交在两条线段的同一个点导致出点入点判断失误的。\r\n                        continue;\r\n                    nt_in++;// 判断交点是出去还是进入 被2整除出 余1进\r\n\r\n                    if (t[i] <= 1) nt++; //统计小于1的个数 用于判断B点是否在内部 被2整除不在 余1在\r\n\r\n                    if (t[i] > 0 && t[i] <= 1)\r\n                    {\r\n                        const p = pLine[itp].P1().add((pLine[itp].P2().sub(pLine[itp].P1())).mut(t[i]));\r\n                        tInp.setPoint(\r\n                            new Point(Math.floor(p.x),Math.floor(p.y))\r\n                        );\r\n                        \r\n                        if(nt_in % 2 == 0) tInp.setJudge(2); //交点，出点\r\n                        else tInp.setJudge(1); // 交点，入点\r\n                        ppoint.push(tInp.copy());\r\n                    }\r\n                }\r\n\r\n                tInp.setPoint(pLine[itp].P2());\r\n                if(nt % 2 == 0) tInp.setJudge(0);//端点\r\n                else tInp.setJudge(1);//交点，入点\r\n                ppoint.push(tInp.copy());\r\n                t = [];\r\n            }\r\n            //对于VIEW的每一条边，找到POLYGON的每一条边与那条边的交点\r\n            for (itv = 0; itv < vLine.length; itv++){\r\n                for (itp = 0; itp < pLine.length; itp++){\r\n                    const {tag,insert,tt} = this.IsInsect(vLine[itv].P1(), vLine[itv].P2(), \r\n                        pLine[itp].P1(), pLine[itp].P2())\r\n                    if(tag){\r\n                        t.push(tt);\r\n                    }\r\n                }\r\n                t.sort();\r\n                let tInp = new InPoint(new Point(0,0));\r\n                let nt = 0;\r\n                let nt_in = 0;\r\n                for (let i = 0; i < t.length; i++)\r\n                {\r\n                // if(i!=0&&t[i]==t[i-1])//避免相交在两条线段的同一个点导致出点入点判断失误的\r\n                //     continue;\r\n                    nt_in++;\r\n                    if (t[i] <= 1) nt++; //统计小于1的个数（也就是B点之前交点的个数）用于判断B点是否在内部 被2整除不在 余1在\r\n\r\n                    if (t[i] > 0 && t[i] <= 1)\r\n                    {\r\n                        const p = vLine[itv].P1().add((vLine[itv].P2().sub(vLine[itv].P1())).mut(t[i]));\r\n                        tInp.setPoint(\r\n                            new Point(Math.floor(p.x),Math.floor(p.y))\r\n                        );\r\n\r\n                        if (nt_in % 2 == 0) tInp.setJudge(2); // 交点，出点\r\n                        else tInp.setJudge(1); // 交点，入点\r\n                        vpoint.push(tInp.copy());\r\n                    }\r\n                }\r\n                tInp.setPoint(vLine[itv].P2());\r\n                if (nt % 2 == 0) tInp.setJudge(0);//端点在外部\r\n                else tInp.setJudge(1);//端点在内部，当作入点标记\r\n                vpoint.push(tInp.copy());\r\n                t = [];\r\n            }\r\n        },\r\n        BoolIntersection(PointInter,Num){\r\n            let ppoint = this.sectionParams.ppoint;\r\n            let vpoint = this.sectionParams.vpoint;\r\n\r\n            let jumpP=true;//true代表跳转到被裁剪多边形，false代表跳转到窗口多边形\r\n            let state=0;//0代表在遍历被裁剪多边形\r\n            let itp,ittemp_back,ittemp;\r\n            let itpi = 0, ittemp_backi = 0, ittempi = 0;\r\n            //先遍历ppoint\r\n            itp=ppoint;\r\n            //P代表被裁剪多边形，V代表窗口多边形\r\n            while(true)\r\n            {   \r\n                if(itp[itpi].getJudge()==1){//如果是入点\r\n                    let Npoint=0;\r\n                    PointInter.push(new Point(itp[itpi].getPoint().x,itp[itpi].getPoint().y));\r\n                    Npoint++;\r\n                    let a=itp[itpi].getPoint().x;\r\n                    let b=itp[itpi].getPoint().y;\r\n                    ittemp_back=itp; ittemp_backi = itpi;\r\n                    itpi++;\r\n                    ittemp=itp; ittempi = itpi;\r\n\r\n                    //如果之前的跳转是跳转到P，那么现在跳转过来之后下次就跳转到V；反之亦然\r\n                    if(!jumpP)jumpP=true;\r\n                    else jumpP=false;\r\n\r\n                    //找到一个入点，以这个入点为起点找这个裁剪区域的其他点\r\n                    while(a!=ittemp[ittempi].getPoint().x||b!=ittemp[ittempi].getPoint().y)\r\n                    {\r\n                        if (ittemp[ittempi].getJudge() == 1)//入点\r\n                        {\r\n                            PointInter.push(new Point(ittemp[ittempi].getPoint().x,ittemp[ittempi].getPoint().y));\r\n                            ittemp[ittempi].setJudge(3); // 标记已经pick的点\r\n                            Npoint++;\r\n                            ittemp_back = ittemp;\r\n                            ittemp_backi = ittempi;\r\n                            ittempi++;\r\n                        }//end入点的情况\r\n                        else if (ittemp[ittempi].getJudge() == 2)//出点，跳转\r\n                        {\r\n                            PointInter.push(new Point(ittemp[ittempi].getPoint().x,ittemp[ittempi].getPoint().y));\r\n\r\n                            ittemp[ittempi].setJudge(3); // 标记已经pick的点\r\n\r\n                            Npoint++;\r\n                            ittemp_back = ittemp;\r\n                            ittemp_backi = ittempi;\r\n\r\n                            if (!jumpP) {//应该跳转到V\r\n                                ittemp = vpoint;\r\n                                ittempi = 0;\r\n                                jumpP = true;//表明下一次应该跳转到P\r\n                            }\r\n                            else//应该跳转到P\r\n                            {\r\n                                ittemp = ppoint;\r\n                                ittempi = 0;\r\n                                jumpP = false;//下一次跳转到V\r\n                            }\r\n \r\n                            //在跳转到的数组中找到对应的点\r\n                            while ( ((ittemp[ittempi].getPoint().x != ittemp_back[ittemp_backi].getPoint().x)||\r\n                                    (ittemp[ittempi].getPoint().y != ittemp_back[ittemp_backi].getPoint().y)))\r\n                            {\r\n                                ittempi++;\r\n                            }\r\n      \r\n                            ittemp[ittempi].setJudge(3); // 标记已经pick的点\r\n\r\n                            ittempi++;\r\n\r\n                            if (ittemp[ittempi].getJudge() == 0)\r\n                                break; // 交点为一个的情况\r\n                        }//end出点的情况\r\n\r\n                        if (!jumpP)\r\n                        {\r\n                        if (ittempi == ppoint.length && ittemp == ppoint)\r\n                        {\r\n                            ittemp = ppoint;\r\n                            ittempi = 0;\r\n                        }\r\n                        }\r\n                        else\r\n                        {\r\n                        if (ittempi == vpoint.length && ittemp == vpoint)\r\n                        {\r\n                            ittemp = vpoint;\r\n                            ittempi = 0;\r\n                        }\r\n                        }\r\n \r\n                    }\r\n\r\n                    Num.push(Npoint);\r\n                    Npoint = 0; //重新计数\r\n                }//找完一个裁剪后的区域了\r\n\r\n                //继续找下一个点，作为裁剪区域的起点\r\n                itpi++;\r\n                if(state==0){//当前在遍历P数组\r\n                    if(itpi==ppoint.length && itp == ppoint){//如果P数组遍历到结尾，那么下次从V开始，并且跳转标记为P\r\n                        itp=vpoint;\r\n                        itpi = 0;\r\n                        jumpP=true;\r\n                        state=1;\r\n                    }\r\n                }\r\n                else{//当前在遍历V数组，V遍历结束，说明整个都结束了\r\n                    if(itpi==vpoint.length && itp == vpoint)\r\n                        break;\r\n                }\r\n\r\n            }//搜索完全部的顶点序列了\r\n        },\r\n        IsInsect(A,B,C,D){\r\n            let t =0;\r\n            let insect;\r\n            const dot = (a,b)=>{\r\n                return a.x*b.x+a.y*b.y;\r\n            }\r\n            let b=B.sub(A);//向量\r\n            let d=D.sub(C);\r\n            let c=C.sub(A);\r\n            let d_V = new Point(d.y,-d.x);//d的垂线\r\n            if(dot(b,d_V)==0)return {tag:false};//平行\r\n            else{\r\n                t=dot(c,d_V)/dot(b,d_V);\r\n                let b_V = new Point(b.y,-b.x);\r\n                let u=dot(c,b_V)/dot(b,d_V);\r\n                if(u<0||u>1)return {tag:false};//线段不相交\r\n                else{//线段相交\r\n                    insect=A.add(new Point(b.x*t,b.y*t));\r\n                    return {tag:true,insect,tt:t};\r\n                }\r\n            }\r\n        },\r\n        SetUI() {\r\n            this.$refs.page.SetUI();\r\n        },\r\n\r\n\r\n    },\r\n    mounted() {\r\n        this.Init();\r\n        this.SetUI();\r\n    },\r\n\r\n};\r\n\r\n</script>\r\n","import Point from \"./Point\";\r\n\r\nexport default class Line{\r\n    constructor(p1,p2){\r\n        this.p1 = new Point(p1.x,p1.y);\r\n        this.p2 = new Point(p2.x,p2.y);;\r\n    }\r\n    P1(){\r\n        return this.p1;\r\n    }\r\n    P2(){\r\n        return this.p2;\r\n    }\r\n}","import Point from \"./Point\";\r\n\r\nexport default class InPoint{\r\n    constructor(point){\r\n        this.point = new Point(point.x,point.y)\r\n    }\r\n    setPoint(point){\r\n        this.point = new Point(point.x,point.y)\r\n    }\r\n    setJudge(jud){\r\n        this.jud = jud; \r\n    }\r\n    getPoint(){\r\n        return this.point\r\n    }\r\n    getJudge(){\r\n        return this.jud;\r\n    }\r\n    copy(){\r\n        let cp = new InPoint(this.point);\r\n        cp.jud = this.jud;\r\n        return cp;\r\n    }\r\n}","import { render } from \"./index.vue?vue&type=template&id=4c9bdcd0&lang=html\"\nimport script from \"./index.vue?vue&type=script&lang=js\"\nexport * from \"./index.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"F:\\\\Note-Haruluya\\\\Project\\\\Rock-sugar\\\\rock-sugar\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["Polygon","constructor","points","this","forEach","e","i","maxPointX","max","element","x","minPointX","min","maxPointY","y","minPointY","size","length","indexValue","index","isInPolygon","point","j","c","_createBlock","_component_nano_cg_experiment_page","prop_des_data","$data","prop_ui_setter","$options","prop_section_params","ref","Line","p1","p2","Point","P1","P2","InPoint","setPoint","setJudge","jud","getPoint","getJudge","copy","cp","desData","category","name","buttonContent","title","content","data","canvas","ctx","sectionParams","pn","vn","pp","vp","pLine","vLine","ppoint","vpoint","innerColor","outerColor","clipColor","debugContent","girdSize","screenTransform","scale","computed","uiSetter","setter","type","id","value","callback","uiSetting","default","push","methods","Init","$refs","page","getCanvas","getContext","setViewer","Render","gridx","parseInt","width","gridy","height","clearRect","points_p","points_v","polyp","polyv","A","B","setX","setY","SetPLane","PointInter","Num","BoolIntersection","it","itN","points_ans","itp","itv","t","tag","insert","tt","IsInsect","sort","tInp","nt","nt_in","p","add","sub","mut","Math","floor","ittemp_back","ittemp","jumpP","state","itpi","ittemp_backi","ittempi","Npoint","a","b","C","D","insect","dot","d","d_V","b_V","u","SetUI","mounted","__exports__","render"],"sourceRoot":""}